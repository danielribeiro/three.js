<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="../build/three.min.js"></script>

		<script src="js/libs/stats.min.js"></script>

		<script>
var animate, camera, container, cube, init, mouseX, mouseXOnMouseDown, onDocumentMouseDown, onDocumentMouseMove, onDocumentMouseOut, onDocumentMouseUp, onDocumentTouchMove, onDocumentTouchStart, onWindowResize, plane, render, renderer, scene, stats, targetRotation, targetRotationOnMouseDown, windowHalfX, windowHalfY;

container = void 0;

stats = void 0;

camera = void 0;

scene = void 0;

renderer = void 0;

cube = void 0;

plane = void 0;

targetRotation = 0;

targetRotationOnMouseDown = 0;

mouseX = 0;

mouseXOnMouseDown = 0;

windowHalfX = window.innerWidth / 2;

windowHalfY = window.innerHeight / 2;

init = function() {
  var geometry, i, info, material;
  container = document.createElement("div");
  document.body.appendChild(container);
  info = document.createElement("div");
  info.style.position = "absolute";
  info.style.top = "10px";
  info.style.width = "100%";
  info.style.textAlign = "center";
  info.innerHTML = "Drag to spin the cube";
  container.appendChild(info);
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.y = 150;
  camera.position.z = 500;
  scene = new THREE.Scene();
  geometry = new THREE.CubeGeometry(200, 200, 200);
  i = 0;
  while (i < geometry.faces.length) {
    geometry.faces[i].color.setHex(Math.random() * 0xffffff);
    i++;
  }
  material = new THREE.MeshBasicMaterial({
    vertexColors: THREE.FaceColors
  });
  cube = new THREE.Mesh(geometry, material);
  cube.position.y = 150;
  scene.add(cube);
  geometry = new THREE.PlaneGeometry(200, 200);
  geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  material = new THREE.MeshBasicMaterial({
    color: 0xe0e0e0
  });
  plane = new THREE.Mesh(geometry, material);
  scene.add(plane);
  renderer = new THREE.CanvasRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);
  stats = new Stats();
  stats.domElement.style.position = "absolute";
  stats.domElement.style.top = "0px";
  container.appendChild(stats.domElement);
  document.addEventListener("mousedown", onDocumentMouseDown, false);
  document.addEventListener("touchstart", onDocumentTouchStart, false);
  document.addEventListener("touchmove", onDocumentTouchMove, false);
  return window.addEventListener("resize", onWindowResize, false);
};

onWindowResize = function() {
  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  return renderer.setSize(window.innerWidth, window.innerHeight);
};

onDocumentMouseDown = function(event) {
  event.preventDefault();
  document.addEventListener("mousemove", onDocumentMouseMove, false);
  document.addEventListener("mouseup", onDocumentMouseUp, false);
  document.addEventListener("mouseout", onDocumentMouseOut, false);
  mouseXOnMouseDown = event.clientX - windowHalfX;
  return targetRotationOnMouseDown = targetRotation;
};

onDocumentMouseMove = function(event) {
  mouseX = event.clientX - windowHalfX;
  return targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
};

onDocumentMouseUp = function(event) {
  document.removeEventListener("mousemove", onDocumentMouseMove, false);
  document.removeEventListener("mouseup", onDocumentMouseUp, false);
  return document.removeEventListener("mouseout", onDocumentMouseOut, false);
};

onDocumentMouseOut = function(event) {
  document.removeEventListener("mousemove", onDocumentMouseMove, false);
  document.removeEventListener("mouseup", onDocumentMouseUp, false);
  return document.removeEventListener("mouseout", onDocumentMouseOut, false);
};

onDocumentTouchStart = function(event) {
  if (event.touches.length === 1) {
    event.preventDefault();
    mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
    return targetRotationOnMouseDown = targetRotation;
  }
};

onDocumentTouchMove = function(event) {
  if (event.touches.length === 1) {
    event.preventDefault();
    mouseX = event.touches[0].pageX - windowHalfX;
    return targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;
  }
};

animate = function() {
  requestAnimationFrame(animate);
  render();
  return stats.update();
};

render = function() {
  plane.rotation.y = cube.rotation.y += (targetRotation - cube.rotation.y) * 0.05;
  return renderer.render(scene, camera);
};

init();

animate();

		</script>

	</body>
</html>
